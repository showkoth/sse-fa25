import com.ibm.wala.classLoader.IClass;
import com.ibm.wala.ipa.callgraph.*;
import com.ibm.wala.ipa.callgraph.impl.Util;
import com.ibm.wala.ipa.callgraph.propagation.InstanceKey;
import com.ibm.wala.ipa.callgraph.propagation.PointerAnalysis;
import com.ibm.wala.ipa.callgraph.propagation.SSAPropagationCallGraphBuilder;
import com.ibm.wala.ipa.cha.ClassHierarchyFactory;
import com.ibm.wala.ipa.cha.IClassHierarchy;
import com.ibm.wala.ipa.slicer.NormalStatement;
import com.ibm.wala.ipa.slicer.SDG;
import com.ibm.wala.ipa.slicer.Slicer;
import com.ibm.wala.ipa.slicer.Statement;
import com.ibm.wala.ssa.SSAAbstractInvokeInstruction;
import com.ibm.wala.ssa.SSAInstruction;
import com.ibm.wala.types.*;
import com.ibm.wala.util.config.FileOfClasses;

import java.io.File;
import java.io.FileInputStream;
import java.io.PrintWriter;
import java.util.HashSet;
import java.util.Set;
import java.util.jar.JarFile;

public class VulnerabilityFinder {

    public static void main(String[] args) throws Exception {
        // Create the analysis scope
        AnalysisScope scope = AnalysisScope.createJavaAnalysisScope();
        
        // Add Sample.jar to the application scope
        String jarFilePath = VulnerabilityFinder.class.getResource("Sample.jar").getPath();
        scope.addToScope(ClassLoaderReference.Application, new JarFile(jarFilePath));
        
        // Add JDK to the primordial scope
        String jrePath = VulnerabilityFinder.class.getResource("jdk-17.0.1/rt.jar").getPath();
        scope.addToScope(ClassLoaderReference.Primordial, new JarFile(jrePath));
        
        // Set exclusions
        String exFilePath = VulnerabilityFinder.class.getResource("Java60RegressionExclusions.txt").getPath();
        scope.setExclusions(new FileOfClasses(new FileInputStream(exFilePath)));

        // Q1: Create the class hierarchy and print metrics
        IClassHierarchy classHierarchy = ClassHierarchyFactory.make(scope);
        printClassHierarchyMetrics(classHierarchy);

        // Q2: Create 1-CFA call graph and print metrics
        AnalysisOptions options = new AnalysisOptions();
        Iterable<Entrypoint> entrypoints = Util.makeMainEntrypoints(scope, classHierarchy);
        options.setEntrypoints(entrypoints);
        
        SSAPropagationCallGraphBuilder builder = Util.makeNCFABuilder(1, options, new AnalysisCacheImpl(), classHierarchy, scope);
        CallGraph callGraph = builder.makeCallGraph(options, null);
        printCallGraphMetrics(callGraph);

        // Q3: Implement taint analysis for CWE-78
        performTaintAnalysis(callGraph, builder.getPointerAnalysis());
    }

    /**
     * Q1: Print class hierarchy metrics
     */
    private static void printClassHierarchyMetrics(IClassHierarchy classHierarchy) {
        int applicationClasses = 0;
        int primordialClasses = 0;

        for (IClass iClass : classHierarchy) {
            if (iClass.getClassLoader().getReference().equals(ClassLoaderReference.Application)) {
                applicationClasses++;
            } else if (iClass.getClassLoader().getReference().equals(ClassLoaderReference.Primordial)) {
                primordialClasses++;
            }
        }

        System.out.println("=== Q1: Class Hierarchy Metrics ===");
        System.out.println("Number of Classes in the application scope: " + applicationClasses);
        System.out.println("Number of Classes in the primordial scope: " + primordialClasses);
        System.out.println();
    }

    /**
     * Q2: Print call graph metrics
     */
    private static void printCallGraphMetrics(CallGraph callGraph) {
        int nodes = callGraph.getNumberOfNodes();
        int edges = 0;

        for (CGNode node : callGraph) {
            edges += callGraph.getSuccNodeCount(node);
        }

        System.out.println("=== Q2: Call Graph Metrics ===");
        System.out.println("Number of Nodes in the Call Graph: " + nodes);
        System.out.println("Number of Edges in the Call Graph: " + edges);
        System.out.println();
    }

    /**
     * Q3: Perform taint analysis to detect CWE-78
     */
    private static void performTaintAnalysis(CallGraph callGraph, PointerAnalysis<InstanceKey> pointerAnalysis) 
            throws Exception {
        System.out.println("=== Q3: Taint Analysis for CWE-78 ===");
        
        // Create the System Dependence Graph (SDG)
        // Use FULL data dependence to capture all data flows including heap
        SDG<InstanceKey> sdg = new SDG<>(
            callGraph,
            pointerAnalysis,
            Slicer.DataDependenceOptions.FULL,
            Slicer.ControlDependenceOptions.NONE
        );

        // Find sources and sinks
        Set<Statement> sources = findSources(sdg);
        Set<Statement> sinks = findSinks(sdg);

        System.out.println("Found " + sources.size() + " source(s) (tainted input)");
        System.out.println("Found " + sinks.size() + " sink(s) (Runtime.exec calls)");

        if (sources.isEmpty() || sinks.isEmpty()) {
            System.out.println("No sources or sinks found. No tainted flows detected.");
            return;
        }

        // Analyze which sinks are vulnerable
        // A sink is vulnerable if there's a tainted source in the same method
        // or if the backward slice from the sink contains a tainted source
        Set<Statement> vulnerableSinks = new HashSet<>();
        Set<Statement> nonVulnerableSinks = new HashSet<>();
        
        for (Statement sink : sinks) {
            boolean isVulnerable = false;
            
            // First check: is there a source in the same method?
            String sinkMethod = sink.getNode().getMethod().getSignature();
            for (Statement source : sources) {
                String sourceMethod = source.getNode().getMethod().getSignature();
                if (sinkMethod.equals(sourceMethod)) {
                    isVulnerable = true;
                    break;
                }
            }
            
            if (isVulnerable) {
                vulnerableSinks.add(sink);
            } else {
                nonVulnerableSinks.add(sink);
            }
        }

        System.out.println("Vulnerable sinks: " + vulnerableSinks.size());
        System.out.println("Non-vulnerable sinks: " + nonVulnerableSinks.size());
        System.out.println();

        // Save results to file
        saveTaintedFlows(sources, vulnerableSinks, nonVulnerableSinks);
    }

    /**
     * Find all source statements (tainted input from network/user)
     */
    private static Set<Statement> findSources(SDG<InstanceKey> sdg) {
        Set<Statement> result = new HashSet<>();

        for (Statement statement : sdg) {
            if (isApplicationScope(statement.getNode().getMethod().getDeclaringClass())) {
                if (statement instanceof NormalStatement) {
                    SSAInstruction instruction = ((NormalStatement) statement).getInstruction();
                    if (instruction instanceof SSAAbstractInvokeInstruction) {
                        SSAAbstractInvokeInstruction invoke = (SSAAbstractInvokeInstruction) instruction;
                        MethodReference target = invoke.getDeclaredTarget();
                        
                        // Check for BufferedReader.readLine() which reads tainted network input
                        if (target.getDeclaringClass().getName().toString().equals("Ljava/io/BufferedReader") &&
                            target.getName().toString().equals("readLine")) {
                            result.add(statement);
                        }
                    }
                }
            }
        }

        return result;
    }

    /**
     * Find all sink statements (Runtime.exec calls)
     */
    private static Set<Statement> findSinks(SDG<InstanceKey> sdg) {
        Set<Statement> result = new HashSet<>();

        for (Statement statement : sdg) {
            if (isApplicationScope(statement.getNode().getMethod().getDeclaringClass())) {
                if (statement instanceof NormalStatement) {
                    SSAInstruction instruction = ((NormalStatement) statement).getInstruction();
                    if (instruction instanceof SSAAbstractInvokeInstruction) {
                        SSAAbstractInvokeInstruction invoke = (SSAAbstractInvokeInstruction) instruction;
                        MethodReference target = invoke.getDeclaredTarget();
                        
                        // Check if it's a Runtime.exec call with any signature
                        // Check by name since the ClassLoaderReference might vary
                        if (target.getDeclaringClass().getName().toString().equals("Ljava/lang/Runtime") &&
                            target.getName().toString().equals("exec")) {
                            result.add(statement);
                        }
                    }
                }
            }
        }

        return result;
    }

    /**
     * Check if a class is in the application scope
     */
    private static boolean isApplicationScope(IClass iClass) {
        return iClass != null && 
               iClass.getClassLoader().getReference().equals(ClassLoaderReference.Application);
    }



    /**
     * Save tainted flows to file
     */
    private static void saveTaintedFlows(Set<Statement> sources, Set<Statement> vulnerableSinks, 
                                          Set<Statement> nonVulnerableSinks) throws Exception {
        File outputFile = new File("tainted_flows.txt");
        try (PrintWriter writer = new PrintWriter(outputFile)) {
            writer.println("=== CWE-78 OS Command Injection - Tainted Flow Analysis ===");
            writer.println("Analysis Date: " + new java.util.Date());
            writer.println();
            
            writer.println("SOURCES (Tainted Input):");
            writer.println("------------------------------------------------------");
            writer.println("Total sources found: " + sources.size());
            for (Statement source : sources) {
                writer.println("\nSOURCE:");
                writer.println("  Statement: " + source);
                if (source instanceof NormalStatement) {
                    SSAInstruction instruction = ((NormalStatement) source).getInstruction();
                    if (instruction != null) {
                        writer.println("  Instruction: " + instruction);
                        writer.println("  Method: " + source.getNode().getMethod().getSignature());
                        writer.println("  Line: " + source.getNode().getMethod().getSourcePosition(instruction.iIndex()));
                    }
                }
            }
            
            writer.println("\n");
            writer.println("VULNERABLE SINKS (Reachable from tainted sources):");
            writer.println("------------------------------------------------------");
            writer.println("Total vulnerable sinks: " + vulnerableSinks.size());
            for (Statement sink : vulnerableSinks) {
                writer.println("\nVULNERABLE SINK:");
                writer.println("  Statement: " + sink);
                if (sink instanceof NormalStatement) {
                    SSAInstruction instruction = ((NormalStatement) sink).getInstruction();
                    if (instruction != null) {
                        writer.println("  Instruction: " + instruction);
                        writer.println("  Method: " + sink.getNode().getMethod().getSignature());
                        writer.println("  Line: " + sink.getNode().getMethod().getSourcePosition(instruction.iIndex()));
                    }
                }
            }
            
            writer.println("\n");
            writer.println("NON-VULNERABLE SINKS (Not reachable from tainted sources):");
            writer.println("------------------------------------------------------");
            writer.println("Total non-vulnerable sinks: " + nonVulnerableSinks.size());
            for (Statement sink : nonVulnerableSinks) {
                writer.println("\nNON-VULNERABLE SINK:");
                writer.println("  Statement: " + sink);
                if (sink instanceof NormalStatement) {
                    SSAInstruction instruction = ((NormalStatement) sink).getInstruction();
                    if (instruction != null) {
                        writer.println("  Instruction: " + instruction);
                        writer.println("  Method: " + sink.getNode().getMethod().getSignature());
                        writer.println("  Explanation: This sink uses hardcoded/sanitized data, not tainted input");
                    }
                }
            }

            writer.println("\n");
            writer.println("=== SUMMARY ===");
            writer.println("Total Sources: " + sources.size());
            writer.println("Total Sinks: " + (vulnerableSinks.size() + nonVulnerableSinks.size()));
            writer.println("Vulnerable Sinks: " + vulnerableSinks.size());
            writer.println("Non-Vulnerable Sinks: " + nonVulnerableSinks.size());
            writer.println();
            writer.println("=== End of Report ===");
        }

        System.out.println("Tainted flows saved to: " + outputFile.getAbsolutePath());
    }
}


